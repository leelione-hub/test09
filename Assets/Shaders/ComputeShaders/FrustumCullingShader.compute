#pragma kernel FrustumCull
#pragma kernel CopyMatrices

// 输入：所有实例的变换矩阵
StructuredBuffer<float4x4> InputMatrices;
StructuredBuffer<float4x4> InputNormalMatrices;
// 输出：通过剔除测试的实例矩阵
RWStructuredBuffer<float4x4> OutputMatrices;
RWStructuredBuffer<float4x4> OutputNormalMatrices;
// 用于CopyMatrices核函数的输出缓冲区
RWStructuredBuffer<float4x4> OutputMatricesCopy;
RWStructuredBuffer<float4x4> OutputNormalMatricesCopy;

RWStructuredBuffer<uint> VisibilityFlags;
RWStructuredBuffer<uint> VisibleCount;



// 视锥体平面（6个平面）
float4 FrustumPlanes[6];
// 实例总数
int InstanceCount;
// 树木的包围球半径
float BoundsRadius;
// 相机位置（用于距离剔除）
float3 CameraPosition;

// 判断点是否在视锥体内
bool IsInFrustum(float3 position, float radius)
{
    for (int i = 0; i < 6; i++)
    {
        float4 plane = FrustumPlanes[i];
        float distance = dot(plane.xyz, position) + plane.w;
        if (distance < -radius)
            return false;
    }
    return true;
}

// 视锥剔除核函数
[numthreads(64, 1, 1)]
void FrustumCull(uint3 id : SV_DispatchThreadID)
{
    if(id.x == 0)
    {
        VisibleCount[0] = 0;
    }

    GroupMemoryBarrierWithGroupSync();
    
    if(id.x >= InstanceCount)
    {
        return;
    }

    float4x4 matrix_x4 = InputMatrices[id.x];
    //float3 position = float3(matrix_x4[0][3], matrix_x4[1][3], matrix_x4[2][3]);
    float3 position = float3(matrix_x4._m03_m13_m23);
    bool isVisible = true; // 直接设置为true进行测试
    isVisible = IsInFrustum(position, BoundsRadius);
    
    if (isVisible)
    {
        // 使用原子操作确保顺序写入
        uint outputIndex;
        InterlockedAdd(VisibleCount[0], 1, outputIndex);
        
        // 按顺序写入输出缓冲区
        OutputMatrices[outputIndex] = matrix_x4;
        OutputNormalMatrices[outputIndex] = InputNormalMatrices[id.x];
    }
    
    // 设置可见性标记（可选，用于调试）
    VisibilityFlags[id.x] = isVisible ? 1u : 0u;
}

// 复制矩阵的核函数
[numthreads(64, 1, 1)]
void CopyMatrices(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= InstanceCount)
        return;
    
    // 从输入缓冲区读取矩阵
    float4x4 matrix_x4 = InputMatrices[id.x];
    
    OutputMatricesCopy[id.x] = matrix_x4;
    OutputNormalMatricesCopy[id.x] = InputNormalMatrices[id.x];
}